{"remainingRequest":"/Users/matt/Sites/motion/node_modules/babel-loader/lib/index.js??ruleSet[1].rules[0].use[1]!/Users/matt/Sites/motion/node_modules/ts-loader/index.js??ruleSet[1].rules[0].use[2]!/Users/matt/Sites/motion/packages/framer-motion/cypress/integration/drag.ts","dependencies":[{"path":"/Users/matt/Sites/motion/packages/framer-motion/cypress/integration/drag.ts","mtime":1635951863848},{"path":"/Users/matt/Sites/motion/node_modules/@pmmmwh/react-refresh-webpack-plugin/loader/index.js","mtime":1641995460598},{"path":"/Users/matt/Sites/motion/node_modules/cache-loader/dist/cjs.js","mtime":1641995460665},{"path":"/Users/matt/Sites/motion/node_modules/babel-loader/lib/index.js","mtime":1641995460018},{"path":"/Users/matt/Sites/motion/node_modules/ts-loader/index.js","mtime":1641995461506}],"contextDependencies":[],"result":["\"use strict\";\n/**\n * In this test suite there's two sets of each test, one without and one with the `layout` prop.\n * This is because when a component has the layout prop applied, we apply drag to the bounding box\n * and when it isn't, we apply it to the x/y transform.\n *\n * Descrepencies between the expected values in the two sets of tests are *something* to do with how\n * pointer events are being resolved with Cypress, but a manual check will verify that both drag modes\n * are working visually the same.\n */\n\ndescribe(\"Drag\", function () {\n  it(\"Drags the element by the defined distance\", function () {\n    cy.visit(\"?test=drag\").get(\"[data-testid='draggable']\").wait(200).trigger(\"pointerdown\", 5, 5).trigger(\"pointermove\", 10, 10) // Gesture will start from first move past threshold\n    .wait(50).trigger(\"pointermove\", 200, 300, {\n      force: true\n    }).wait(50).trigger(\"pointerup\", {\n      force: true\n    }).should(function ($draggable) {\n      var draggable = $draggable[0];\n\n      var _a = draggable.getBoundingClientRect(),\n          left = _a.left,\n          top = _a.top;\n\n      expect(left).to.equal(200);\n      expect(top).to.equal(300);\n    });\n  });\n  it(\"Drags the element by the defined distance with different initial offset\", function () {\n    cy.visit(\"?test=drag&x=100&y=100\").get(\"[data-testid='draggable']\").wait(200).trigger(\"pointerdown\", 5, 5).trigger(\"pointermove\", 10, 10) // Gesture will start from first move past threshold\n    .wait(50).trigger(\"pointermove\", 200, 300, {\n      force: true\n    }).wait(50).trigger(\"pointerup\", {\n      force: true\n    }).should(function ($draggable) {\n      var draggable = $draggable[0];\n\n      var _a = draggable.getBoundingClientRect(),\n          left = _a.left,\n          top = _a.top;\n\n      expect(left).to.equal(300); // TODO: This should actually be 400, but for some reason the test scroll\n      // scrolls an additional 100px when dragging starts. But this has been manually verified\n      // as working\n\n      expect(top).to.equal(300);\n    });\n  });\n  it(\"Drags the element by the defined distance with percentage initial offset\", function () {\n    cy.visit(\"?test=drag&x=200%&y=200%\").get(\"[data-testid='draggable']\").wait(200).trigger(\"pointerdown\", 5, 5).trigger(\"pointermove\", 10, 10) // Gesture will start from first move past threshold\n    .wait(50).trigger(\"pointermove\", 200, 300, {\n      force: true\n    }).wait(50).trigger(\"pointerup\", {\n      force: true\n    }).should(function ($draggable) {\n      var draggable = $draggable[0];\n\n      var _a = draggable.getBoundingClientRect(),\n          left = _a.left,\n          top = _a.top;\n\n      expect(left).to.equal(300); // TODO: This should actually be 400, but for some reason the test scroll\n      // scrolls an additional 100px when dragging starts. But this has been manually verified\n      // as working\n\n      expect(top).to.equal(300);\n    });\n  });\n  it(\"Locks drag to x\", function () {\n    cy.visit(\"?test=drag&axis=x\").get(\"[data-testid='draggable']\").wait(200).trigger(\"pointerdown\", 5, 5).wait(50).trigger(\"pointermove\", 10, 10) // Gesture will start from first move past threshold\n    .wait(50).trigger(\"pointermove\", 200, 300, {\n      force: true\n    }).wait(50).trigger(\"pointerup\", {\n      force: true\n    }).should(function ($draggable) {\n      var draggable = $draggable[0];\n\n      var _a = draggable.getBoundingClientRect(),\n          left = _a.left,\n          top = _a.top;\n\n      expect(left).to.equal(200);\n      expect(top).to.equal(0);\n    });\n  });\n  it(\"Locks drag to y\", function () {\n    cy.visit(\"?test=drag&axis=y\").get(\"[data-testid='draggable']\").wait(200).trigger(\"pointerdown\", 5, 5).trigger(\"pointermove\", 10, 10) // Gesture will start from first move past threshold\n    .wait(50).trigger(\"pointermove\", 200, 300, {\n      force: true\n    }).wait(50).trigger(\"pointerup\", {\n      force: true\n    }).should(function ($draggable) {\n      var draggable = $draggable[0];\n\n      var _a = draggable.getBoundingClientRect(),\n          left = _a.left,\n          top = _a.top;\n\n      expect(left).to.equal(0);\n      expect(top).to.equal(300);\n    });\n  }); // Having trouble making this test work\n  // it(\"Direction locks to x\", () => {\n  //     cy.reload()\n  //     cy.visit(\"?test=drag&lock=true\")\n  //         .wait(200)\n  //         .get(\"[data-testid='draggable']\")\n  //         .wait(200)\n  //         .trigger(\"pointerdown\", 5, 5, { force: true })\n  //         .trigger(\"pointermove\", 5, 5, { force: true }) // Gesture will start from first move past threshold\n  //         .wait(100)\n  //         .trigger(\"pointermove\", 200, 10, { force: true })\n  //         .wait(50)\n  //         .trigger(\"pointermove\", 10, 200, { force: true })\n  //         .wait(100)\n  //         .trigger(\"pointerup\", { force: true })\n  //         .should(($draggable: any) => {\n  //             const draggable = $draggable[0] as HTMLDivElement\n  //             const { left, top } = draggable.getBoundingClientRect()\n  //             expect(top).to.equal(0)\n  //             expect(left).to.equal(200)\n  //         })\n  // })\n\n  it(\"Direction locks to y\", function () {\n    cy.reload();\n    cy.visit(\"?test=drag&lock=true\").wait(200).get(\"[data-testid='draggable']\").wait(200).trigger(\"pointerdown\", 5, 5, {\n      force: true\n    }).wait(50).trigger(\"pointermove\", 10, 10, {\n      force: true\n    }) // Gesture will start from first move past threshold\n    .wait(100).trigger(\"pointermove\", 10, 200, {\n      force: true\n    }).wait(100).trigger(\"pointermove\", 200, 10, {\n      force: true\n    }).wait(100).trigger(\"pointerup\", {\n      force: true\n    }).should(function ($draggable) {\n      var draggable = $draggable[0];\n\n      var _a = draggable.getBoundingClientRect(),\n          left = _a.left,\n          top = _a.top;\n\n      expect(left).to.equal(0);\n      expect(top).to.equal(200);\n    });\n  });\n  it(\"Constraints as object: bottom right\", function () {\n    cy.visit(\"?test=drag&right=100&bottom=100\").wait(200).get(\"[data-testid='draggable']\").wait(100).trigger(\"pointerdown\", 5, 5).trigger(\"pointermove\", 10, 10) // Gesture will start from first move past threshold\n    .wait(50).trigger(\"pointermove\", 200, 200, {\n      force: true\n    }).wait(50).trigger(\"pointerup\", {\n      force: true\n    }).should(function ($draggable) {\n      var draggable = $draggable[0];\n\n      var _a = draggable.getBoundingClientRect(),\n          left = _a.left,\n          top = _a.top;\n\n      expect(left).to.equal(100);\n      expect(top).to.equal(100);\n    });\n  });\n  it(\"Constraints as object: top left\", function () {\n    cy.visit(\"?test=drag&left=-10&top=-10\").wait(200).get(\"[data-testid='draggable']\").wait(100).trigger(\"pointerdown\", 40, 40).trigger(\"pointermove\", 30, 30) // Gesture will start from first move past threshold\n    .wait(50).trigger(\"pointermove\", 10, 10, {\n      force: true\n    }).wait(50).trigger(\"pointerup\", {\n      force: true\n    }).should(function ($draggable) {\n      var draggable = $draggable[0];\n\n      var _a = draggable.getBoundingClientRect(),\n          left = _a.left,\n          top = _a.top;\n\n      expect(left).to.equal(-10);\n      expect(top).to.equal(-10);\n    });\n  });\n  it(\"Element returns to center with dragSnapToOrigin\", function () {\n    cy.visit(\"?test=drag&return=true&left=-10&top=-10\").wait(200).get(\"[data-testid='draggable']\").wait(100).trigger(\"pointerdown\", 40, 40).trigger(\"pointermove\", 30, 30) // Gesture will start from first move past threshold\n    .wait(50).trigger(\"pointermove\", 10, 10, {\n      force: true\n    }).wait(50).should(function ($draggable) {\n      var draggable = $draggable[0];\n\n      var _a = draggable.getBoundingClientRect(),\n          left = _a.left,\n          top = _a.top;\n\n      expect(left).to.equal(-10);\n      expect(top).to.equal(-10);\n    }).trigger(\"pointerup\", {\n      force: true\n    }).wait(50).should(function ($draggable) {\n      var draggable = $draggable[0];\n\n      var _a = draggable.getBoundingClientRect(),\n          left = _a.left,\n          top = _a.top;\n\n      expect(left).to.equal(0);\n      expect(top).to.equal(0);\n    });\n  });\n  it(\"doesn't reset drag constraints (ref-based), while dragging, on unrelated parent component updates\", function () {\n    cy.visit(\"?test=drag-ref-constraints\").wait(200).get(\"[data-testid='draggable']\").trigger(\"pointerdown\", 10, 10).trigger(\"pointermove\", 15, 15).wait(50).trigger(\"pointermove\", 300, 300, {\n      force: true\n    }).wait(50).trigger(\"pointerup\", {\n      force: true\n    }).should(function ($draggable) {\n      var draggable = $draggable[0];\n\n      var _a = draggable.getBoundingClientRect(),\n          left = _a.left,\n          top = _a.top;\n\n      expect(left).to.equal(150);\n      expect(top).to.equal(150);\n    });\n  });\n  it(\"rescales draggable element in relation to resized constraints\", function () {\n    cy.visit(\"?test=drag-ref-constraints-resize\").wait(200).get(\"#constraints\").should(function (_a) {\n      var $constraints = _a[0];\n\n      var _b = $constraints.getBoundingClientRect(),\n          left = _b.left,\n          top = _b.top,\n          right = _b.right,\n          bottom = _b.bottom;\n\n      expect(left).to.equal(250);\n      expect(top).to.equal(0);\n      expect(right).to.equal(750);\n      expect(bottom).to.equal(300);\n    }).get(\"#box\").should(function (_a) {\n      var $box = _a[0];\n\n      var _b = $box.getBoundingClientRect(),\n          left = _b.left,\n          top = _b.top,\n          right = _b.right,\n          bottom = _b.bottom;\n\n      expect(left).to.equal(400);\n      expect(top).to.equal(50);\n      expect(right).to.equal(600);\n      expect(bottom).to.equal(250);\n    }).trigger(\"pointerdown\", 5, 5).trigger(\"pointermove\", 10, 10) // Gesture will start from first move past threshold\n    .wait(50).trigger(\"pointermove\", 100, 100, {\n      force: true\n    }).wait(50).trigger(\"pointerup\", {\n      force: true\n    }).get(\"#box\").should(function (_a) {\n      var $box = _a[0];\n\n      var _b = $box.getBoundingClientRect(),\n          left = _b.left,\n          top = _b.top,\n          right = _b.right,\n          bottom = _b.bottom;\n\n      expect(left).to.equal(550);\n      expect(top).to.equal(100);\n      expect(right).to.equal(750);\n      expect(bottom).to.equal(300);\n    });\n    cy.viewport(800, 660).wait(50).get(\"#constraints\").should(function (_a) {\n      var $constraints = _a[0];\n\n      var _b = $constraints.getBoundingClientRect(),\n          left = _b.left,\n          right = _b.right;\n\n      expect(left).to.equal(200);\n      expect(right).to.equal(600);\n    }).get(\"#box\").should(function (_a) {\n      var $box = _a[0];\n\n      var _b = $box.getBoundingClientRect(),\n          left = _b.left,\n          right = _b.right;\n\n      expect(left).to.equal(400);\n      expect(right).to.equal(600);\n    });\n    cy.viewport(1000, 660).wait(50).get(\"#constraints\").should(function (_a) {\n      var $constraints = _a[0];\n\n      var _b = $constraints.getBoundingClientRect(),\n          left = _b.left,\n          top = _b.top,\n          right = _b.right,\n          bottom = _b.bottom;\n\n      expect(left).to.equal(250);\n      expect(top).to.equal(0);\n      expect(right).to.equal(750);\n      expect(bottom).to.equal(300);\n    }).get(\"#box\").should(function (_a) {\n      var $box = _a[0];\n\n      var _b = $box.getBoundingClientRect(),\n          left = _b.left,\n          right = _b.right;\n\n      expect(left).to.equal(550);\n      expect(right).to.equal(750);\n    });\n  });\n  it(\"Snaps to cursor\", function () {\n    cy.visit(\"?test=drag-snap-to-cursor\").wait(200).scrollTo(0, 800).get(\"#scrollable\").should(function (_a) {\n      var $scrollable = _a[0];\n\n      var _b = $scrollable.getBoundingClientRect(),\n          top = _b.top,\n          left = _b.left,\n          right = _b.right,\n          bottom = _b.bottom;\n\n      expect(top).to.equal(200);\n      expect(right).to.equal(740);\n      expect(bottom).to.equal(500);\n      expect(left).to.equal(240);\n    }).get(\"#scroll-trigger\").trigger(\"pointerdown\", 5, 5).wait(50).get(\"#scrollable\").should(function (_a) {\n      var $scrollable = _a[0];\n\n      var _b = $scrollable.getBoundingClientRect(),\n          top = _b.top,\n          left = _b.left,\n          right = _b.right,\n          bottom = _b.bottom;\n\n      expect(top).to.equal(-125);\n      expect(right).to.equal(275);\n      expect(bottom).to.equal(175);\n      expect(left).to.equal(-225);\n    });\n  });\n});\ndescribe(\"Drag & Layout\", function () {\n  it(\"Drags the element by the defined distance\", function () {\n    cy.visit(\"?test=drag&layout=true\").get(\"[data-testid='draggable']\").wait(200).trigger(\"pointerdown\", 5, 5).trigger(\"pointermove\", 10, 10) // Gesture will start from first move past threshold\n    .wait(50).trigger(\"pointermove\", 200, 300, {\n      force: true\n    }).wait(50).trigger(\"pointerup\", {\n      force: true\n    }).should(function ($draggable) {\n      var draggable = $draggable[0];\n\n      var _a = draggable.getBoundingClientRect(),\n          left = _a.left,\n          top = _a.top;\n\n      expect(left).to.equal(200);\n      expect(top).to.equal(300);\n    });\n  });\n  it(\"Drags the element by the defined distance with different initial offset\", function () {\n    cy.visit(\"?test=drag&x=100&y=100&layout=true\").get(\"[data-testid='draggable']\").wait(200).trigger(\"pointerdown\", 5, 5).trigger(\"pointermove\", 10, 10) // Gesture will start from first move past threshold\n    .wait(50).trigger(\"pointermove\", 200, 300, {\n      force: true\n    }).wait(50).trigger(\"pointerup\", {\n      force: true\n    }).should(function ($draggable) {\n      var draggable = $draggable[0];\n\n      var _a = draggable.getBoundingClientRect(),\n          left = _a.left,\n          top = _a.top;\n\n      expect(left).to.equal(300); // TODO: This should actually be 400, but for some reason the test scroll\n      // scrolls an additional 100px when dragging starts. But this has been manually verified\n      // as working\n\n      expect(top).to.equal(300);\n    });\n  });\n  it(\"Locks drag to x\", function () {\n    cy.visit(\"?test=drag&axis=x&layout=true\").get(\"[data-testid='draggable']\").wait(200).trigger(\"pointerdown\", 5, 5).trigger(\"pointermove\", 10, 10) // Gesture will start from first move past threshold\n    .wait(50).trigger(\"pointermove\", 200, 300, {\n      force: true\n    }).wait(50).trigger(\"pointerup\", {\n      force: true\n    }).should(function ($draggable) {\n      var draggable = $draggable[0];\n\n      var _a = draggable.getBoundingClientRect(),\n          left = _a.left,\n          top = _a.top;\n\n      expect(left).to.equal(200);\n      expect(top).to.equal(0);\n    });\n  });\n  it(\"Locks drag to y\", function () {\n    cy.visit(\"?test=drag&axis=y&layout=true\").get(\"[data-testid='draggable']\").wait(200).trigger(\"pointerdown\", 5, 5).trigger(\"pointermove\", 10, 10) // Gesture will start from first move past threshold\n    .wait(50).trigger(\"pointermove\", 200, 300, {\n      force: true\n    }).wait(50).trigger(\"pointerup\", {\n      force: true\n    }).should(function ($draggable) {\n      var draggable = $draggable[0];\n\n      var _a = draggable.getBoundingClientRect(),\n          left = _a.left,\n          top = _a.top;\n\n      expect(left).to.equal(0);\n      expect(top).to.equal(300);\n    });\n  }); // Having trouble making this test work\n  // it(\"Direction locks to x\", () => {\n  //     cy.reload()\n  //     cy.visit(\"?test=drag&lock=true&layout=true\")\n  //         .wait(100)\n  //         .get(\"[data-testid='draggable']\")\n  //         .wait(200)\n  //         .trigger(\"pointerdown\", 5, 5, { force: true })\n  //         .wait(50)\n  //         .trigger(\"pointermove\", 5, 5, { force: true }) // Gesture will start from first move past threshold\n  //         .wait(100)\n  //         .trigger(\"pointermove\", 200, 10, { force: true })\n  //         .wait(50)\n  //         .trigger(\"pointermove\", 10, 200, { force: true })\n  //         .wait(100)\n  //         .trigger(\"pointerup\", { force: true })\n  //         .should(($draggable: any) => {\n  //             const draggable = $draggable[0] as HTMLDivElement\n  //             const { left, top } = draggable.getBoundingClientRect()\n  //             expect(left).to.equal(190)\n  //             expect(top).to.equal(0)\n  //         })\n  // })\n\n  it(\"Direction locks to y\", function () {\n    cy.visit(\"?test=drag&lock=true&layout=true\").wait(100).get(\"[data-testid='draggable']\").wait(200).trigger(\"pointerdown\", 5, 5, {\n      force: true\n    }).trigger(\"pointermove\", 10, 10, {\n      force: true\n    }) // Gesture will start from first move past threshold\n    .wait(100).trigger(\"pointermove\", 10, 200, {\n      force: true\n    }).wait(100).trigger(\"pointermove\", 200, 10, {\n      force: true\n    }).wait(100).trigger(\"pointerup\", {\n      force: true\n    }).should(function ($draggable) {\n      var draggable = $draggable[0];\n\n      var _a = draggable.getBoundingClientRect(),\n          left = _a.left,\n          top = _a.top;\n\n      expect(left).to.equal(0);\n      expect(top).to.equal(200);\n    });\n  });\n  it(\"Constraints as object: bottom right\", function () {\n    cy.visit(\"?test=drag&right=100&bottom=100&layout=true\").wait(200).get(\"[data-testid='draggable']\").trigger(\"pointerdown\", 5, 5).trigger(\"pointermove\", 10, 10) // Gesture will start from first move past threshold\n    .wait(50).trigger(\"pointermove\", 200, 200, {\n      force: true\n    }).wait(50).trigger(\"pointerup\", {\n      force: true\n    }).should(function ($draggable) {\n      var draggable = $draggable[0];\n\n      var _a = draggable.getBoundingClientRect(),\n          left = _a.left,\n          top = _a.top;\n\n      expect(left).to.equal(100);\n      expect(top).to.equal(100);\n    });\n  });\n  it(\"Constraints as object: top left\", function () {\n    cy.visit(\"?test=drag&left=-10&top=-10&layout=true\").wait(200).get(\"[data-testid='draggable']\").trigger(\"pointerdown\", 40, 40).trigger(\"pointermove\", 30, 30) // Gesture will start from first move past threshold\n    .wait(50).trigger(\"pointermove\", 10, 10, {\n      force: true\n    }).wait(50).trigger(\"pointerup\", {\n      force: true\n    }).should(function ($draggable) {\n      var draggable = $draggable[0];\n\n      var _a = draggable.getBoundingClientRect(),\n          left = _a.left,\n          top = _a.top;\n\n      expect(left).to.equal(-10);\n      expect(top).to.equal(-10);\n    });\n  });\n  it(\"doesn't reset drag constraints (ref-based), while dragging, on unrelated parent component updates\", function () {\n    cy.visit(\"?test=drag-ref-constraints&layout=true\").wait(200).get(\"[data-testid='draggable']\").trigger(\"pointerdown\", 10, 10).trigger(\"pointermove\", 15, 15).wait(50).trigger(\"pointermove\", 300, 300, {\n      force: true\n    }).wait(50).trigger(\"pointerup\", {\n      force: true\n    }).should(function ($draggable) {\n      var draggable = $draggable[0];\n\n      var _a = draggable.getBoundingClientRect(),\n          left = _a.left,\n          top = _a.top;\n\n      expect(left).to.equal(150);\n      expect(top).to.equal(150);\n    });\n  });\n});",{"version":3,"sources":["/Users/matt/Sites/motion/packages/framer-motion/cypress/integration/drag.ts"],"names":["describe","it","cy","visit","get","wait","trigger","force","should","$draggable","draggable","_a","getBoundingClientRect","left","top","expect","to","equal","reload","$constraints","_b","right","bottom","$box","viewport","scrollTo","$scrollable"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * In this test suite there's two sets of each test, one without and one with the `layout` prop.\n * This is because when a component has the layout prop applied, we apply drag to the bounding box\n * and when it isn't, we apply it to the x/y transform.\n *\n * Descrepencies between the expected values in the two sets of tests are *something* to do with how\n * pointer events are being resolved with Cypress, but a manual check will verify that both drag modes\n * are working visually the same.\n */\ndescribe(\"Drag\", function () {\n    it(\"Drags the element by the defined distance\", function () {\n        cy.visit(\"?test=drag\")\n            .get(\"[data-testid='draggable']\")\n            .wait(200)\n            .trigger(\"pointerdown\", 5, 5)\n            .trigger(\"pointermove\", 10, 10) // Gesture will start from first move past threshold\n            .wait(50)\n            .trigger(\"pointermove\", 200, 300, { force: true })\n            .wait(50)\n            .trigger(\"pointerup\", { force: true })\n            .should(function ($draggable) {\n            var draggable = $draggable[0];\n            var _a = draggable.getBoundingClientRect(), left = _a.left, top = _a.top;\n            expect(left).to.equal(200);\n            expect(top).to.equal(300);\n        });\n    });\n    it(\"Drags the element by the defined distance with different initial offset\", function () {\n        cy.visit(\"?test=drag&x=100&y=100\")\n            .get(\"[data-testid='draggable']\")\n            .wait(200)\n            .trigger(\"pointerdown\", 5, 5)\n            .trigger(\"pointermove\", 10, 10) // Gesture will start from first move past threshold\n            .wait(50)\n            .trigger(\"pointermove\", 200, 300, { force: true })\n            .wait(50)\n            .trigger(\"pointerup\", { force: true })\n            .should(function ($draggable) {\n            var draggable = $draggable[0];\n            var _a = draggable.getBoundingClientRect(), left = _a.left, top = _a.top;\n            expect(left).to.equal(300);\n            // TODO: This should actually be 400, but for some reason the test scroll\n            // scrolls an additional 100px when dragging starts. But this has been manually verified\n            // as working\n            expect(top).to.equal(300);\n        });\n    });\n    it(\"Drags the element by the defined distance with percentage initial offset\", function () {\n        cy.visit(\"?test=drag&x=200%&y=200%\")\n            .get(\"[data-testid='draggable']\")\n            .wait(200)\n            .trigger(\"pointerdown\", 5, 5)\n            .trigger(\"pointermove\", 10, 10) // Gesture will start from first move past threshold\n            .wait(50)\n            .trigger(\"pointermove\", 200, 300, { force: true })\n            .wait(50)\n            .trigger(\"pointerup\", { force: true })\n            .should(function ($draggable) {\n            var draggable = $draggable[0];\n            var _a = draggable.getBoundingClientRect(), left = _a.left, top = _a.top;\n            expect(left).to.equal(300);\n            // TODO: This should actually be 400, but for some reason the test scroll\n            // scrolls an additional 100px when dragging starts. But this has been manually verified\n            // as working\n            expect(top).to.equal(300);\n        });\n    });\n    it(\"Locks drag to x\", function () {\n        cy.visit(\"?test=drag&axis=x\")\n            .get(\"[data-testid='draggable']\")\n            .wait(200)\n            .trigger(\"pointerdown\", 5, 5)\n            .wait(50)\n            .trigger(\"pointermove\", 10, 10) // Gesture will start from first move past threshold\n            .wait(50)\n            .trigger(\"pointermove\", 200, 300, { force: true })\n            .wait(50)\n            .trigger(\"pointerup\", { force: true })\n            .should(function ($draggable) {\n            var draggable = $draggable[0];\n            var _a = draggable.getBoundingClientRect(), left = _a.left, top = _a.top;\n            expect(left).to.equal(200);\n            expect(top).to.equal(0);\n        });\n    });\n    it(\"Locks drag to y\", function () {\n        cy.visit(\"?test=drag&axis=y\")\n            .get(\"[data-testid='draggable']\")\n            .wait(200)\n            .trigger(\"pointerdown\", 5, 5)\n            .trigger(\"pointermove\", 10, 10) // Gesture will start from first move past threshold\n            .wait(50)\n            .trigger(\"pointermove\", 200, 300, { force: true })\n            .wait(50)\n            .trigger(\"pointerup\", { force: true })\n            .should(function ($draggable) {\n            var draggable = $draggable[0];\n            var _a = draggable.getBoundingClientRect(), left = _a.left, top = _a.top;\n            expect(left).to.equal(0);\n            expect(top).to.equal(300);\n        });\n    });\n    // Having trouble making this test work\n    // it(\"Direction locks to x\", () => {\n    //     cy.reload()\n    //     cy.visit(\"?test=drag&lock=true\")\n    //         .wait(200)\n    //         .get(\"[data-testid='draggable']\")\n    //         .wait(200)\n    //         .trigger(\"pointerdown\", 5, 5, { force: true })\n    //         .trigger(\"pointermove\", 5, 5, { force: true }) // Gesture will start from first move past threshold\n    //         .wait(100)\n    //         .trigger(\"pointermove\", 200, 10, { force: true })\n    //         .wait(50)\n    //         .trigger(\"pointermove\", 10, 200, { force: true })\n    //         .wait(100)\n    //         .trigger(\"pointerup\", { force: true })\n    //         .should(($draggable: any) => {\n    //             const draggable = $draggable[0] as HTMLDivElement\n    //             const { left, top } = draggable.getBoundingClientRect()\n    //             expect(top).to.equal(0)\n    //             expect(left).to.equal(200)\n    //         })\n    // })\n    it(\"Direction locks to y\", function () {\n        cy.reload();\n        cy.visit(\"?test=drag&lock=true\")\n            .wait(200)\n            .get(\"[data-testid='draggable']\")\n            .wait(200)\n            .trigger(\"pointerdown\", 5, 5, { force: true })\n            .wait(50)\n            .trigger(\"pointermove\", 10, 10, { force: true }) // Gesture will start from first move past threshold\n            .wait(100)\n            .trigger(\"pointermove\", 10, 200, { force: true })\n            .wait(100)\n            .trigger(\"pointermove\", 200, 10, { force: true })\n            .wait(100)\n            .trigger(\"pointerup\", { force: true })\n            .should(function ($draggable) {\n            var draggable = $draggable[0];\n            var _a = draggable.getBoundingClientRect(), left = _a.left, top = _a.top;\n            expect(left).to.equal(0);\n            expect(top).to.equal(200);\n        });\n    });\n    it(\"Constraints as object: bottom right\", function () {\n        cy.visit(\"?test=drag&right=100&bottom=100\")\n            .wait(200)\n            .get(\"[data-testid='draggable']\")\n            .wait(100)\n            .trigger(\"pointerdown\", 5, 5)\n            .trigger(\"pointermove\", 10, 10) // Gesture will start from first move past threshold\n            .wait(50)\n            .trigger(\"pointermove\", 200, 200, { force: true })\n            .wait(50)\n            .trigger(\"pointerup\", { force: true })\n            .should(function ($draggable) {\n            var draggable = $draggable[0];\n            var _a = draggable.getBoundingClientRect(), left = _a.left, top = _a.top;\n            expect(left).to.equal(100);\n            expect(top).to.equal(100);\n        });\n    });\n    it(\"Constraints as object: top left\", function () {\n        cy.visit(\"?test=drag&left=-10&top=-10\")\n            .wait(200)\n            .get(\"[data-testid='draggable']\")\n            .wait(100)\n            .trigger(\"pointerdown\", 40, 40)\n            .trigger(\"pointermove\", 30, 30) // Gesture will start from first move past threshold\n            .wait(50)\n            .trigger(\"pointermove\", 10, 10, { force: true })\n            .wait(50)\n            .trigger(\"pointerup\", { force: true })\n            .should(function ($draggable) {\n            var draggable = $draggable[0];\n            var _a = draggable.getBoundingClientRect(), left = _a.left, top = _a.top;\n            expect(left).to.equal(-10);\n            expect(top).to.equal(-10);\n        });\n    });\n    it(\"Element returns to center with dragSnapToOrigin\", function () {\n        cy.visit(\"?test=drag&return=true&left=-10&top=-10\")\n            .wait(200)\n            .get(\"[data-testid='draggable']\")\n            .wait(100)\n            .trigger(\"pointerdown\", 40, 40)\n            .trigger(\"pointermove\", 30, 30) // Gesture will start from first move past threshold\n            .wait(50)\n            .trigger(\"pointermove\", 10, 10, { force: true })\n            .wait(50)\n            .should(function ($draggable) {\n            var draggable = $draggable[0];\n            var _a = draggable.getBoundingClientRect(), left = _a.left, top = _a.top;\n            expect(left).to.equal(-10);\n            expect(top).to.equal(-10);\n        })\n            .trigger(\"pointerup\", { force: true })\n            .wait(50)\n            .should(function ($draggable) {\n            var draggable = $draggable[0];\n            var _a = draggable.getBoundingClientRect(), left = _a.left, top = _a.top;\n            expect(left).to.equal(0);\n            expect(top).to.equal(0);\n        });\n    });\n    it(\"doesn't reset drag constraints (ref-based), while dragging, on unrelated parent component updates\", function () {\n        cy.visit(\"?test=drag-ref-constraints\")\n            .wait(200)\n            .get(\"[data-testid='draggable']\")\n            .trigger(\"pointerdown\", 10, 10)\n            .trigger(\"pointermove\", 15, 15)\n            .wait(50)\n            .trigger(\"pointermove\", 300, 300, { force: true })\n            .wait(50)\n            .trigger(\"pointerup\", { force: true })\n            .should(function ($draggable) {\n            var draggable = $draggable[0];\n            var _a = draggable.getBoundingClientRect(), left = _a.left, top = _a.top;\n            expect(left).to.equal(150);\n            expect(top).to.equal(150);\n        });\n    });\n    it(\"rescales draggable element in relation to resized constraints\", function () {\n        cy.visit(\"?test=drag-ref-constraints-resize\")\n            .wait(200)\n            .get(\"#constraints\")\n            .should(function (_a) {\n            var $constraints = _a[0];\n            var _b = $constraints.getBoundingClientRect(), left = _b.left, top = _b.top, right = _b.right, bottom = _b.bottom;\n            expect(left).to.equal(250);\n            expect(top).to.equal(0);\n            expect(right).to.equal(750);\n            expect(bottom).to.equal(300);\n        })\n            .get(\"#box\")\n            .should(function (_a) {\n            var $box = _a[0];\n            var _b = $box.getBoundingClientRect(), left = _b.left, top = _b.top, right = _b.right, bottom = _b.bottom;\n            expect(left).to.equal(400);\n            expect(top).to.equal(50);\n            expect(right).to.equal(600);\n            expect(bottom).to.equal(250);\n        })\n            .trigger(\"pointerdown\", 5, 5)\n            .trigger(\"pointermove\", 10, 10) // Gesture will start from first move past threshold\n            .wait(50)\n            .trigger(\"pointermove\", 100, 100, { force: true })\n            .wait(50)\n            .trigger(\"pointerup\", { force: true })\n            .get(\"#box\")\n            .should(function (_a) {\n            var $box = _a[0];\n            var _b = $box.getBoundingClientRect(), left = _b.left, top = _b.top, right = _b.right, bottom = _b.bottom;\n            expect(left).to.equal(550);\n            expect(top).to.equal(100);\n            expect(right).to.equal(750);\n            expect(bottom).to.equal(300);\n        });\n        cy.viewport(800, 660)\n            .wait(50)\n            .get(\"#constraints\")\n            .should(function (_a) {\n            var $constraints = _a[0];\n            var _b = $constraints.getBoundingClientRect(), left = _b.left, right = _b.right;\n            expect(left).to.equal(200);\n            expect(right).to.equal(600);\n        })\n            .get(\"#box\")\n            .should(function (_a) {\n            var $box = _a[0];\n            var _b = $box.getBoundingClientRect(), left = _b.left, right = _b.right;\n            expect(left).to.equal(400);\n            expect(right).to.equal(600);\n        });\n        cy.viewport(1000, 660)\n            .wait(50)\n            .get(\"#constraints\")\n            .should(function (_a) {\n            var $constraints = _a[0];\n            var _b = $constraints.getBoundingClientRect(), left = _b.left, top = _b.top, right = _b.right, bottom = _b.bottom;\n            expect(left).to.equal(250);\n            expect(top).to.equal(0);\n            expect(right).to.equal(750);\n            expect(bottom).to.equal(300);\n        })\n            .get(\"#box\")\n            .should(function (_a) {\n            var $box = _a[0];\n            var _b = $box.getBoundingClientRect(), left = _b.left, right = _b.right;\n            expect(left).to.equal(550);\n            expect(right).to.equal(750);\n        });\n    });\n    it(\"Snaps to cursor\", function () {\n        cy.visit(\"?test=drag-snap-to-cursor\")\n            .wait(200)\n            .scrollTo(0, 800)\n            .get(\"#scrollable\")\n            .should(function (_a) {\n            var $scrollable = _a[0];\n            var _b = $scrollable.getBoundingClientRect(), top = _b.top, left = _b.left, right = _b.right, bottom = _b.bottom;\n            expect(top).to.equal(200);\n            expect(right).to.equal(740);\n            expect(bottom).to.equal(500);\n            expect(left).to.equal(240);\n        })\n            .get(\"#scroll-trigger\")\n            .trigger(\"pointerdown\", 5, 5)\n            .wait(50)\n            .get(\"#scrollable\")\n            .should(function (_a) {\n            var $scrollable = _a[0];\n            var _b = $scrollable.getBoundingClientRect(), top = _b.top, left = _b.left, right = _b.right, bottom = _b.bottom;\n            expect(top).to.equal(-125);\n            expect(right).to.equal(275);\n            expect(bottom).to.equal(175);\n            expect(left).to.equal(-225);\n        });\n    });\n});\ndescribe(\"Drag & Layout\", function () {\n    it(\"Drags the element by the defined distance\", function () {\n        cy.visit(\"?test=drag&layout=true\")\n            .get(\"[data-testid='draggable']\")\n            .wait(200)\n            .trigger(\"pointerdown\", 5, 5)\n            .trigger(\"pointermove\", 10, 10) // Gesture will start from first move past threshold\n            .wait(50)\n            .trigger(\"pointermove\", 200, 300, { force: true })\n            .wait(50)\n            .trigger(\"pointerup\", { force: true })\n            .should(function ($draggable) {\n            var draggable = $draggable[0];\n            var _a = draggable.getBoundingClientRect(), left = _a.left, top = _a.top;\n            expect(left).to.equal(200);\n            expect(top).to.equal(300);\n        });\n    });\n    it(\"Drags the element by the defined distance with different initial offset\", function () {\n        cy.visit(\"?test=drag&x=100&y=100&layout=true\")\n            .get(\"[data-testid='draggable']\")\n            .wait(200)\n            .trigger(\"pointerdown\", 5, 5)\n            .trigger(\"pointermove\", 10, 10) // Gesture will start from first move past threshold\n            .wait(50)\n            .trigger(\"pointermove\", 200, 300, { force: true })\n            .wait(50)\n            .trigger(\"pointerup\", { force: true })\n            .should(function ($draggable) {\n            var draggable = $draggable[0];\n            var _a = draggable.getBoundingClientRect(), left = _a.left, top = _a.top;\n            expect(left).to.equal(300);\n            // TODO: This should actually be 400, but for some reason the test scroll\n            // scrolls an additional 100px when dragging starts. But this has been manually verified\n            // as working\n            expect(top).to.equal(300);\n        });\n    });\n    it(\"Locks drag to x\", function () {\n        cy.visit(\"?test=drag&axis=x&layout=true\")\n            .get(\"[data-testid='draggable']\")\n            .wait(200)\n            .trigger(\"pointerdown\", 5, 5)\n            .trigger(\"pointermove\", 10, 10) // Gesture will start from first move past threshold\n            .wait(50)\n            .trigger(\"pointermove\", 200, 300, { force: true })\n            .wait(50)\n            .trigger(\"pointerup\", { force: true })\n            .should(function ($draggable) {\n            var draggable = $draggable[0];\n            var _a = draggable.getBoundingClientRect(), left = _a.left, top = _a.top;\n            expect(left).to.equal(200);\n            expect(top).to.equal(0);\n        });\n    });\n    it(\"Locks drag to y\", function () {\n        cy.visit(\"?test=drag&axis=y&layout=true\")\n            .get(\"[data-testid='draggable']\")\n            .wait(200)\n            .trigger(\"pointerdown\", 5, 5)\n            .trigger(\"pointermove\", 10, 10) // Gesture will start from first move past threshold\n            .wait(50)\n            .trigger(\"pointermove\", 200, 300, { force: true })\n            .wait(50)\n            .trigger(\"pointerup\", { force: true })\n            .should(function ($draggable) {\n            var draggable = $draggable[0];\n            var _a = draggable.getBoundingClientRect(), left = _a.left, top = _a.top;\n            expect(left).to.equal(0);\n            expect(top).to.equal(300);\n        });\n    });\n    // Having trouble making this test work\n    // it(\"Direction locks to x\", () => {\n    //     cy.reload()\n    //     cy.visit(\"?test=drag&lock=true&layout=true\")\n    //         .wait(100)\n    //         .get(\"[data-testid='draggable']\")\n    //         .wait(200)\n    //         .trigger(\"pointerdown\", 5, 5, { force: true })\n    //         .wait(50)\n    //         .trigger(\"pointermove\", 5, 5, { force: true }) // Gesture will start from first move past threshold\n    //         .wait(100)\n    //         .trigger(\"pointermove\", 200, 10, { force: true })\n    //         .wait(50)\n    //         .trigger(\"pointermove\", 10, 200, { force: true })\n    //         .wait(100)\n    //         .trigger(\"pointerup\", { force: true })\n    //         .should(($draggable: any) => {\n    //             const draggable = $draggable[0] as HTMLDivElement\n    //             const { left, top } = draggable.getBoundingClientRect()\n    //             expect(left).to.equal(190)\n    //             expect(top).to.equal(0)\n    //         })\n    // })\n    it(\"Direction locks to y\", function () {\n        cy.visit(\"?test=drag&lock=true&layout=true\")\n            .wait(100)\n            .get(\"[data-testid='draggable']\")\n            .wait(200)\n            .trigger(\"pointerdown\", 5, 5, { force: true })\n            .trigger(\"pointermove\", 10, 10, { force: true }) // Gesture will start from first move past threshold\n            .wait(100)\n            .trigger(\"pointermove\", 10, 200, { force: true })\n            .wait(100)\n            .trigger(\"pointermove\", 200, 10, { force: true })\n            .wait(100)\n            .trigger(\"pointerup\", { force: true })\n            .should(function ($draggable) {\n            var draggable = $draggable[0];\n            var _a = draggable.getBoundingClientRect(), left = _a.left, top = _a.top;\n            expect(left).to.equal(0);\n            expect(top).to.equal(200);\n        });\n    });\n    it(\"Constraints as object: bottom right\", function () {\n        cy.visit(\"?test=drag&right=100&bottom=100&layout=true\")\n            .wait(200)\n            .get(\"[data-testid='draggable']\")\n            .trigger(\"pointerdown\", 5, 5)\n            .trigger(\"pointermove\", 10, 10) // Gesture will start from first move past threshold\n            .wait(50)\n            .trigger(\"pointermove\", 200, 200, { force: true })\n            .wait(50)\n            .trigger(\"pointerup\", { force: true })\n            .should(function ($draggable) {\n            var draggable = $draggable[0];\n            var _a = draggable.getBoundingClientRect(), left = _a.left, top = _a.top;\n            expect(left).to.equal(100);\n            expect(top).to.equal(100);\n        });\n    });\n    it(\"Constraints as object: top left\", function () {\n        cy.visit(\"?test=drag&left=-10&top=-10&layout=true\")\n            .wait(200)\n            .get(\"[data-testid='draggable']\")\n            .trigger(\"pointerdown\", 40, 40)\n            .trigger(\"pointermove\", 30, 30) // Gesture will start from first move past threshold\n            .wait(50)\n            .trigger(\"pointermove\", 10, 10, { force: true })\n            .wait(50)\n            .trigger(\"pointerup\", { force: true })\n            .should(function ($draggable) {\n            var draggable = $draggable[0];\n            var _a = draggable.getBoundingClientRect(), left = _a.left, top = _a.top;\n            expect(left).to.equal(-10);\n            expect(top).to.equal(-10);\n        });\n    });\n    it(\"doesn't reset drag constraints (ref-based), while dragging, on unrelated parent component updates\", function () {\n        cy.visit(\"?test=drag-ref-constraints&layout=true\")\n            .wait(200)\n            .get(\"[data-testid='draggable']\")\n            .trigger(\"pointerdown\", 10, 10)\n            .trigger(\"pointermove\", 15, 15)\n            .wait(50)\n            .trigger(\"pointermove\", 300, 300, { force: true })\n            .wait(50)\n            .trigger(\"pointerup\", { force: true })\n            .should(function ($draggable) {\n            var draggable = $draggable[0];\n            var _a = draggable.getBoundingClientRect(), left = _a.left, top = _a.top;\n            expect(left).to.equal(150);\n            expect(top).to.equal(150);\n        });\n    });\n});\n"]}]}